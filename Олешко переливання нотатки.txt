Слайд 1: Титульний

До вашої уваги доповідь на тему «Розв'язання задачі про переливання: Prolog проти Haskell». Автор роботи: Олешко Дар'я, група 3. Тему присвячено порівняльному аналізу двох декларативних підходів до пошуку оптимального шляху в просторі станів. Анотація: реалізовано алгоритм пошуку в ширину (BFS) для гарантії знаходження найкоротшого рішення, проведено оптимізацію структур даних та порівняно ефективність реалізацій.


Слайд 2: Постановка задачі та абстракція стану

Суть задачі полягає в отриманні цільового об'єму рідини за допомогою посудин фіксованого об'єму без мірних поділок. Представлення стану системи відрізняється між реалізаціями. У Prolog використано список структур b(Current, Capacity), що необхідно через нестійкість порядку посудин.мУ Haskell використано типізований список цілих чисел через його зручність використання та виведення.  Ключовою вимогою, яку ставив автор, було знаходження саме найкоротшої послідовності дій, а не просто будь-якого шляху.


Слайд 3: Пастка "природного" алгоритму (Огляд рішень)

Під час огляду наявних рішень у відкритих джерелах виявлено, що більшість реалізацій використовують пошук у глибину (DFS). Це зумовлено тим, що механізми рекурсії та бектрекінгу є «рідними» для цих мов. Недоліки типових рішень: DFS знаходить перший ліпший, а не оптимальний шлях, схильний до зациклення та марних обчислень. Тому автором реалізовано підхід на базі алгоритму BFS (пошук у ширину). Оцінка внеску:

    Використання ідей з відкритих джерел (синтаксис, базові операції, BFS в загальній формі): 40%.
    Адаптація BFS під мови та задачу, розв'язок специфічних проблем: 60%.


Слайд 4: Реалізація на Prolog (Боротьба з парадигмою)

Специфіка Prolog полягає в тому, що він намагається знайти рішення через уніфікацію в глибину. Для реалізації BFS довелося вручну керувати чергою станів. Важливе уточнення: У роботі свідомо не використано CLP (Constraint Logic Programming). Хоча CLP дозволяє ефективно вирішувати задачі на обмеження, переливання є класичною задачею пошуку шляху в графі. Використання чистого Prolog дозволило продемонструвати логіку роботи алгоритму. На слайді показано фрагмент коду з предикатом findall, де відбувається збір наступних станів. Також критичним рішенням стало використання msort для канонізації станів — це вирішило проблему, коли стани [A,B] та [B,A] вважалися різними. (Нестійкість порідку ємностей виникла через використання select для обробки кожної з них.)


Слайд 5: Реалізація на Haskell (Структури даних)

У функціональній реалізації виникла проблема продуктивності. Стандартний список Haskell має лінійну складність при додаванні в кінець, що перетворювало алгоритм BFS на квадратичний. Рішення: Як показано на слайді, стандартні списки замінено на структури Data.Sequence та Data.Set, що забезпечують доступ за час O(1). Це дозволило досягти миттєвого виконання програми.


Слайд 6: Основні проблеми та виклики

У процесі роботи вирішено низку проблем:
    Відмова від DFS: Незважаючи на складність реалізації, відмова від DFS була необхідною заради якості результату.
    Архітектура: Найбільшою складністю була реалізація «глобальної пам'яті» (списку відвіданих вершин та черги) у чистих функціях, де змінні незмінні. Це вимагало явного прокидання акумуляторів через усі рекурсивні виклики.
    Мислення: Необхідність адаптувати імперативний алгоритм BFS під реляційну логіку Prolog.
    Необхідність канонізації станів у Prolog.
    Демонстрація розв'язку у Prolog: через нестійкість порідку мала місце спроба подати розв'язок як список дій, але врешті-решт цей формат виявивя нечитабельним.


Слайд 7: Порівняння реалізацій

Порівняльний аналіз показав:
    Prolog: Код виглядає як набір фактів. Він компактний, але потік виконання важко відстежити без трасування.
    Haskell: Код суворо типізований, логіка виконання прозора завдяки типам даних. Обидві реалізації в результаті зведені до ідентичної логіки та повертають однаковий оптимальний результат.


Слайд 8: Висновки

Висновки роботи:
    Міф про зручність декларативних мов для будь-яких задач розвіяно: для реалізації BFS довелося боротися з «природою» мови.
    Вибір правильного алгоритму (BFS) та структури даних виявився важливішим за вибір мови програмування.

Рефлексія:
    Трудомісткість: Робота зайняла приблизно ден на виконання та день на оформлення.
    Використання ШІ: Інструменти ШІ (Gemini) використовувалися для консультацій щодо синтаксису (для Data.Sequence та Data.Set також), пошуку по форумах та генерації тестів. Алгоритмічне ядро розроблено самостійно.

На слайді наведено посилання на репозиторій з кодом, відео-презентацію роботи. Список 30+ вкладок форумів та гайдів (опорних джерел), на жаль, не був збережений. Дякую за увагу.
